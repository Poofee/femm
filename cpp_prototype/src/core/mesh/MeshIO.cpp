#include "MeshIO.h"
#include <fstream>
#include <sstream>
#include <iostream>
#include <regex>
#include <stdexcept>

namespace elmer {

// MeshIO类实现
std::shared_ptr<Mesh> MeshIO::loadElmerMesh(const std::string& filename) {
    std::ifstream file(filename);
    if (!file.is_open()) {
        throw std::runtime_error("Cannot open Elmer mesh file: " + filename);
    }
    
    auto mesh = std::make_shared<Mesh>("Loaded from " + filename);
    
    std::string line;
    size_t numberOfNodes = 0;
    size_t numberOfBulkElements = 0;
    size_t numberOfBoundaryElements = 0;
    
    // 读取网格基本信息
    while (std::getline(file, line)) {
        if (line.find("Number of nodes") != std::string::npos) {
            std::istringstream iss(line);
            std::string dummy;
            iss >> dummy >> dummy >> dummy >> numberOfNodes;
        }
        else if (line.find("Number of bulk elements") != std::string::npos) {
            std::istringstream iss(line);
            std::string dummy;
            iss >> dummy >> dummy >> dummy >> dummy >> numberOfBulkElements;
        }
        else if (line.find("Number of boundary elements") != std::string::npos) {
            std::istringstream iss(line);
            std::string dummy;
            iss >> dummy >> dummy >> dummy >> dummy >> numberOfBoundaryElements;
        }
        
        if (numberOfNodes > 0 && numberOfBulkElements > 0) {
            break;
        }
    }
    
    // 读取节点数据
    readNodes(file, mesh, numberOfNodes);
    
    // 读取体单元数据
    readBulkElements(file, mesh, numberOfBulkElements);
    
    // 读取边界单元数据
    if (numberOfBoundaryElements > 0) {
        readBoundaryElements(file, mesh, numberOfBoundaryElements);
    }
    
    file.close();
    
    // 初始化网格
    mesh->initializeParallelInfo();
    
    return mesh;
}

bool MeshIO::saveElmerMesh(const std::shared_ptr<Mesh>& mesh, const std::string& filename) {
    if (!mesh.get()) {
        throw std::invalid_argument("Mesh pointer is null");
    }
    
    std::ofstream file(filename);
    if (!file.is_open()) {
        return false;
    }
    
    // 写入网格头信息
    file << "! ElmerGrid input file generated by ElmerCpp\n";
    file << "! Mesh: " << mesh->getName() << "\n";
    file << "! Number of nodes: " << mesh->numberOfNodes() << "\n";
    file << "! Number of bulk elements: " << mesh->numberOfBulkElements() << "\n";
    file << "! Number of boundary elements: " << mesh->numberOfBoundaryElements() << "\n";
    file << "!\n";
    
    // 写入节点数据
    writeNodes(file, mesh);
    
    // 写入体单元数据
    writeBulkElements(file, mesh);
    
    // 写入边界单元数据
    writeBoundaryElements(file, mesh);
    
    file.close();
    return true;
}

std::shared_ptr<Mesh> MeshIO::loadGmshMesh(const std::string& filename) {
    std::ifstream file(filename);
    if (!file.is_open()) {
        throw std::runtime_error("Cannot open Gmsh mesh file: " + filename);
    }
    
    auto mesh = std::make_shared<Mesh>("Loaded from Gmsh: " + filename);
    
    std::string line;
    bool inNodesSection = false;
    bool inElementsSection = false;
    size_t nodeCount = 0;
    size_t elementCount = 0;
    
    while (std::getline(file, line)) {
        // 跳过注释和空行
        if (line.empty() || line[0] == '#') {
            continue;
        }
        
        // 检查节点段开始
        if (line.find("$Nodes") != std::string::npos) {
            inNodesSection = true;
            inElementsSection = false;
            std::getline(file, line); // 读取节点数量
            nodeCount = std::stoi(line);
            continue;
        }
        
        // 检查单元段开始
        if (line.find("$Elements") != std::string::npos) {
            inNodesSection = false;
            inElementsSection = true;
            std::getline(file, line); // 读取单元数量
            elementCount = std::stoi(line);
            continue;
        }
        
        // 检查段结束
        if (line.find("$End") != std::string::npos) {
            inNodesSection = false;
            inElementsSection = false;
            continue;
        }
        
        // 读取节点数据
        if (inNodesSection && nodeCount > 0) {
            std::istringstream iss(line);
            size_t nodeId;
            double x, y, z;
            iss >> nodeId >> x >> y >> z;
            
            // Gmsh节点ID从1开始，我们需要转换为0开始
            mesh->getNodes().addNode(x, y, z);
            nodeCount--;
        }
        
        // 读取单元数据
        if (inElementsSection && elementCount > 0) {
            std::istringstream iss(line);
            size_t elementId, elementType, numTags;
            iss >> elementId >> elementType >> numTags;
            
            // 跳过标签
            for (size_t i = 0; i < numTags; ++i) {
                size_t tag;
                iss >> tag;
            }
            
            // 读取节点索引
            std::vector<size_t> nodeIndices;
            size_t nodeIndex;
            while (iss >> nodeIndex) {
                // Gmsh节点索引从1开始，转换为0开始
                nodeIndices.push_back(nodeIndex - 1);
            }
            
            // 根据Gmsh单元类型创建对应元素
            ElementType elmerType = gmshToElmerElementType(elementType);
            if (elmerType != ElementType::UNKNOWN) {
                Element element(elmerType);
                element.setNodeIndices(nodeIndices);
                
                // 判断是体单元还是边界单元
                if (isBulkElement(elmerType)) {
                    mesh->addBulkElement(element);
                } else {
                    mesh->addBoundaryElement(element);
                }
            }
            
            elementCount--;
        }
    }
    
    file.close();
    
    // 初始化网格
    mesh->initializeParallelInfo();
    
    return mesh;
}

bool MeshIO::exportToVTK(const std::shared_ptr<Mesh>& mesh, const std::string& filename) {
    if (!mesh.get()) {
        throw std::invalid_argument("Mesh pointer is null");
    }
    
    std::ofstream file(filename);
    if (!file.is_open()) {
        return false;
    }
    
    // 写入VTK头信息
    file << "# vtk DataFile Version 3.0\n";
    file << "ElmerCpp Mesh Export: " << mesh->getName() << "\n";
    file << "ASCII\n";
    file << "DATASET UNSTRUCTURED_GRID\n";
    
    // 写入节点数据
    writeVTKNodes(file, mesh);
    
    // 写入单元数据
    writeVTKElements(file, mesh);
    
    file.close();
    return true;
}

std::shared_ptr<Mesh> MeshIO::createTestMesh(const std::string& name) {
    auto mesh = std::make_shared<Mesh>(name);
    
    // 创建简单立方体网格用于测试
    mesh->getNodes().addNode(0.0, 0.0, 0.0);
    mesh->getNodes().addNode(1.0, 0.0, 0.0);
    mesh->getNodes().addNode(1.0, 1.0, 0.0);
    mesh->getNodes().addNode(0.0, 1.0, 0.0);
    mesh->getNodes().addNode(0.0, 0.0, 1.0);
    mesh->getNodes().addNode(1.0, 0.0, 1.0);
    mesh->getNodes().addNode(1.0, 1.0, 1.0);
    mesh->getNodes().addNode(0.0, 1.0, 1.0);
    
    // 创建立方体单元（六面体）
    Element hexElement(ElementType::HEXAHEDRON);
    for (size_t i = 0; i < 8; ++i) {
        hexElement.addNodeIndex(i);
    }
    mesh->addBulkElement(hexElement);
    
    // 创建边界单元（四边形）
    std::vector<std::vector<size_t>> boundaryFaces = {
        {0, 1, 2, 3}, // 底面
        {4, 5, 6, 7}, // 顶面
        {0, 1, 5, 4}, // 前面
        {1, 2, 6, 5}, // 右面
        {2, 3, 7, 6}, // 后面
        {3, 0, 4, 7}  // 左面
    };
    
    for (size_t i = 0; i < boundaryFaces.size(); ++i) {
        Element boundaryElement(ElementType::LINEAR);
        boundaryElement.setBoundaryId(i + 1);
        boundaryElement.setNodeIndices(boundaryFaces[i]);
        mesh->addBoundaryElement(boundaryElement);
    }
    
    // 初始化网格
    mesh->initializeParallelInfo();
    
    return mesh;
}

// 私有方法实现
void MeshIO::readNodes(std::ifstream& file, std::shared_ptr<Mesh> mesh, size_t numberOfNodes) {
    std::string line;
    
    // 跳过空行和注释
    while (std::getline(file, line)) {
        if (!line.empty() && line[0] != '!' && line[0] != '#') {
            break;
        }
    }
    
    // 读取节点数据
    for (size_t i = 0; i < numberOfNodes; ++i) {
        std::istringstream iss(line);
        size_t nodeId;
        double x, y, z;
        iss >> nodeId >> x >> y >> z;
        
        mesh->getNodes().addNode(x, y, z);
        
        if (i < numberOfNodes - 1) {
            std::getline(file, line);
        }
    }
}

void MeshIO::readBulkElements(std::ifstream& file, std::shared_ptr<Mesh> mesh, size_t numberOfBulkElements) {
    std::string line;
    
    // 跳过空行和注释
    while (std::getline(file, line)) {
        if (!line.empty() && line[0] != '!' && line[0] != '#') {
            break;
        }
    }
    
    // 读取体单元数据
    for (size_t i = 0; i < numberOfBulkElements; ++i) {
        std::istringstream iss(line);
        size_t elementId, elementType, numNodes;
        iss >> elementId >> elementType >> numNodes;
        
        Element element(static_cast<ElementType>(elementType));
        
        // 读取节点索引
        for (size_t j = 0; j < numNodes; ++j) {
            size_t nodeIndex;
            iss >> nodeIndex;
            element.addNodeIndex(nodeIndex - 1); // Elmer网格节点索引从1开始
        }
        
        mesh->addBulkElement(element);
        
        if (i < numberOfBulkElements - 1) {
            std::getline(file, line);
        }
    }
}

void MeshIO::readBoundaryElements(std::ifstream& file, std::shared_ptr<Mesh> mesh, size_t numberOfBoundaryElements) {
    std::string line;
    
    // 跳过空行和注释
    while (std::getline(file, line)) {
        if (!line.empty() && line[0] != '!' && line[0] != '#') {
            break;
        }
    }
    
    // 读取边界单元数据
    for (size_t i = 0; i < numberOfBoundaryElements; ++i) {
        std::istringstream iss(line);
        size_t elementId, boundaryId, numNodes;
        iss >> elementId >> boundaryId >> numNodes;
        
        Element element(ElementType::LINEAR);
        element.setBoundaryId(boundaryId);
        
        // 读取节点索引
        for (size_t j = 0; j < numNodes; ++j) {
            size_t nodeIndex;
            iss >> nodeIndex;
            element.addNodeIndex(nodeIndex - 1); // Elmer网格节点索引从1开始
        }
        
        mesh->addBoundaryElement(element);
        
        if (i < numberOfBoundaryElements - 1) {
            std::getline(file, line);
        }
    }
}

void MeshIO::writeNodes(std::ofstream& file, const std::shared_ptr<Mesh>& mesh) {
    file << "$ Nodes\n";
    
    const auto& nodes = mesh->getNodes().getNodes();
    for (size_t i = 0; i < nodes.size(); ++i) {
        file << (i + 1) << " " << nodes[i].x << " " << nodes[i].y << " " << nodes[i].z << "\n";
    }
    
    file << "$ EndNodes\n\n";
}

void MeshIO::writeBulkElements(std::ofstream& file, const std::shared_ptr<Mesh>& mesh) {
    file << "$ Elements\n";
    
    const auto& elements = mesh->getBulkElements();
    for (size_t i = 0; i < elements.size(); ++i) {
        const auto& element = elements[i];
        file << (i + 1) << " " << static_cast<int>(element.getType()) 
             << " " << element.numberOfNodes();
        
        const auto& indices = element.getNodeIndices();
        for (size_t nodeIndex : indices) {
            file << " " << (nodeIndex + 1);
        }
        
        file << "\n";
    }
    
    file << "$ EndElements\n\n";
}

void MeshIO::writeBoundaryElements(std::ofstream& file, const std::shared_ptr<Mesh>& mesh) {
    file << "$ BoundaryElements\n";
    
    const auto& elements = mesh->getBoundaryElements();
    for (size_t i = 0; i < elements.size(); ++i) {
        const auto& element = elements[i];
        file << (i + 1) << " " << element.getBoundaryId() 
             << " " << element.numberOfNodes();
        
        const auto& indices = element.getNodeIndices();
        for (size_t nodeIndex : indices) {
            file << " " << (nodeIndex + 1);
        }
        
        file << "\n";
    }
    
    file << "$ EndBoundaryElements\n";
}

void MeshIO::writeVTKNodes(std::ofstream& file, const std::shared_ptr<Mesh>& mesh) {
    file << "POINTS " << mesh->numberOfNodes() << " double\n";
    
    const auto& nodes = mesh->getNodes().getNodes();
    for (const auto& node : nodes) {
        file << node.x << " " << node.y << " " << node.z << "\n";
    }
    file << "\n";
}

void MeshIO::writeVTKElements(std::ofstream& file, const std::shared_ptr<Mesh>& mesh) {
    // 计算总单元数和连接性数据大小
    size_t totalElements = mesh->totalElements();
    size_t connectivitySize = 0;
    
    for (const auto& element : mesh->getBulkElements()) {
        connectivitySize += element.numberOfNodes() + 1;
    }
    for (const auto& element : mesh->getBoundaryElements()) {
        connectivitySize += element.numberOfNodes() + 1;
    }
    
    file << "CELLS " << totalElements << " " << connectivitySize << "\n";
    
    // 写入体单元
    for (const auto& element : mesh->getBulkElements()) {
        const auto& indices = element.getNodeIndices();
        file << indices.size();
        for (size_t index : indices) {
            file << " " << index;
        }
        file << "\n";
    }
    
    // 写入边界单元
    for (const auto& element : mesh->getBoundaryElements()) {
        const auto& indices = element.getNodeIndices();
        file << indices.size();
        for (size_t index : indices) {
            file << " " << index;
        }
        file << "\n";
    }
    file << "\n";
    
    // 写入单元类型
    file << "CELL_TYPES " << totalElements << "\n";
    
    // 写入体单元类型
    for (const auto& element : mesh->getBulkElements()) {
        file << elmerToVTKElementType(element.getType()) << "\n";
    }
    
    // 写入边界单元类型
    for (const auto& element : mesh->getBoundaryElements()) {
        file << elmerToVTKElementType(element.getType()) << "\n";
    }
    file << "\n";
}

ElementType MeshIO::gmshToElmerElementType(int gmshType) {
    switch (gmshType) {
        case 1: return ElementType::LINEAR;        // 2节点线
        case 2: return ElementType::TRIANGLE;      // 3节点三角形
        case 3: return ElementType::QUADRILATERAL; // 4节点四边形
        case 4: return ElementType::TETRAHEDRON;   // 4节点四面体
        case 5: return ElementType::HEXAHEDRON;    // 8节点六面体
        case 6: return ElementType::PRISM;         // 6节点棱柱
        case 7: return ElementType::PYRAMID;       // 5节点金字塔
        default: return ElementType::UNKNOWN;
    }
}

bool MeshIO::isBulkElement(ElementType type) {
    switch (type) {
        case ElementType::TETRAHEDRON:
        case ElementType::HEXAHEDRON:
        case ElementType::PRISM:
        case ElementType::PYRAMID:
            return true;
        default:
            return false;
    }
}

int MeshIO::elmerToVTKElementType(ElementType elmerType) {
    switch (elmerType) {
        case ElementType::LINEAR:        return 3;  // VTK_LINE
        case ElementType::TRIANGLE:      return 5;  // VTK_TRIANGLE
        case ElementType::QUADRILATERAL: return 9;  // VTK_QUAD
        case ElementType::TETRAHEDRON:   return 10; // VTK_TETRA
        case ElementType::HEXAHEDRON:    return 12; // VTK_HEXAHEDRON
        case ElementType::PRISM:         return 13; // VTK_WEDGE
        case ElementType::PYRAMID:       return 14; // VTK_PYRAMID
        default:                         return 1;  // VTK_VERTEX
    }
}

} // namespace elmer